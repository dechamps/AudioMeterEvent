using System.Reflection;

[assembly: System.Reflection.AssemblyTitle("MMDeviceAPIHelpers")]
[assembly: System.Reflection.AssemblyDescription("Convenience helpers for dealing with IMMDevice and related APIs")]
[assembly: System.Reflection.AssemblyProduct("AudioMeterEvent")]
[assembly: System.Reflection.AssemblyCompany("Etienne Dechamps")]
[assembly: System.Reflection.AssemblyCopyright("Etienne Dechamps <etienne@edechamps.fr>")]

namespace AudioMeterEvent
{
    public static class MMDeviceAPIHelpers
    {
        public const uint DEVICE_STATE_ACTIVE = 1;
        public const uint STGM_READ = 0;

        // From functiondiscoverykeys_devpkey.h
        public static readonly MMDeviceAPI._tagpropertykey PKEY_Device_FriendlyName = new MMDeviceAPI._tagpropertykey { fmtid = new System.Guid(0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0), pid = 14 };

        public static MMDeviceAPI.IMMDevice GetDeviceById(this MMDeviceAPI.MMDeviceEnumerator deviceEnumerator, string deviceId)
        {
            deviceEnumerator.GetDevice(deviceId, out var device);
            return device;
        }

        public static MMDeviceAPI.IMMDeviceCollection GetDeviceCollection(this MMDeviceAPI.MMDeviceEnumerator deviceEnumerator, MMDeviceAPI.EDataFlow dataFlow, uint stateMask)
        {
            deviceEnumerator.EnumAudioEndpoints(dataFlow, stateMask, out var deviceCollection);
            return deviceCollection;
        }

        public static System.Collections.Generic.IEnumerable<MMDeviceAPI.IMMDevice> GetDevices(this MMDeviceAPI.IMMDeviceCollection deviceCollection)
        {
            deviceCollection.GetCount(out var deviceCount);
            for (uint deviceIndex = 0; deviceIndex < deviceCount; ++deviceIndex)
            {
                deviceCollection.Item(deviceIndex, out var device);
                yield return device;
            }
        }

        public static string Id(this MMDeviceAPI.IMMDevice device) {
            device.GetId(out var id);
            return id;
        }

        public static MMDeviceAPI.IPropertyStore GetPropertyStore(this MMDeviceAPI.IMMDevice device, uint sgtmAccess)
        {
            device.OpenPropertyStore(MMDeviceAPIHelpers.STGM_READ, out var propertyStore);
            return propertyStore;
        }

        public static object Get(this MMDeviceAPI.IPropertyStore propertyStore, MMDeviceAPI._tagpropertykey propertyKey)
        {
            propertyStore.GetValue(MMDeviceAPIHelpers.PKEY_Device_FriendlyName, out var propvariant);
            return propvariant.ToObject();
        }

        public static T ActivateInterface<T>(this MMDeviceAPI.IMMDevice device) where T : class
        {
            var guid = new System.Guid(typeof(T).GetCustomAttribute<System.Runtime.InteropServices.GuidAttribute>(false).Value);
            // Normally we're supposed to pass NULL as pActivationParams but C# won't let us pass null to a ref struct argument. Passing an empty PROPVARIANT seems to work fine.
            var activationParams = new MMDeviceAPI.tag_inner_PROPVARIANT();
            device.Activate(ref guid, (uint) CLSCTX.CLSCTX_ALL, ref activationParams, out var interfacePtr);
            object iface;
            try
            {
                iface = System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(interfacePtr, typeof(T));
            }
            finally
            {
                System.Runtime.InteropServices.Marshal.Release(interfacePtr);
            }
            return iface as T;
        }

        static object ToObject(this MMDeviceAPI.tag_inner_PROPVARIANT propvariant)
        {
            var marshalledPropvariant = propvariant.Marshall();
            PropVariantToVariant(ref marshalledPropvariant, out var variant);
            PropVariantClear(ref marshalledPropvariant);
            return variant;
        }

        static Propvariant Marshall(this MMDeviceAPI.tag_inner_PROPVARIANT propvariant)
        {
            // Note: it seems unlikely this will work with complicated/exotic PROPVARIANT types.
            var marshalledPropvariant = new Propvariant();
            marshalledPropvariant.vt = propvariant.vt;
            // TODO: it's not clear if this autogenerated field name is stable.
            marshalledPropvariant.p = propvariant.__MIDL____MIDL_itf_mmdeviceapi_0003_00930001.pcVal;
            return marshalledPropvariant;
        }

        [System.Runtime.InteropServices.DllImport(@"propsys.dll", PreserveSig = false)]
        static extern void PropVariantToVariant(ref Propvariant pPropVar, [System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.Struct)] out object pVar);

        [System.Runtime.InteropServices.DllImport(@"ole32.dll", PreserveSig = false)]
        static extern void PropVariantClear(ref Propvariant pvar);

        // Unmanaged memory layout for a PROPVARIANT.
        // From https://blogs.msdn.microsoft.com/adamroot/2008/04/11/interop-with-propvariants-in-net/
        // Note that MMDeviceAPI.tag_inner_PROPVARIANT has a completely different memory layout because it is the result of COM interop unmarshalling.
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
        struct Propvariant
        {
            public ushort vt;
            ushort wReserved1;
            ushort wReserved2;
            ushort wReserved3;
            public System.IntPtr p;
            int p2;
        }

        // https://www.pinvoke.net/default.aspx/Enums/CLSCTX.html
        [System.Flags]
        enum CLSCTX : uint
        {
            CLSCTX_INPROC_SERVER = 0x1,
            CLSCTX_INPROC_HANDLER = 0x2,
            CLSCTX_LOCAL_SERVER = 0x4,
            CLSCTX_INPROC_SERVER16 = 0x8,
            CLSCTX_REMOTE_SERVER = 0x10,
            CLSCTX_INPROC_HANDLER16 = 0x20,
            CLSCTX_RESERVED1 = 0x40,
            CLSCTX_RESERVED2 = 0x80,
            CLSCTX_RESERVED3 = 0x100,
            CLSCTX_RESERVED4 = 0x200,
            CLSCTX_NO_CODE_DOWNLOAD = 0x400,
            CLSCTX_RESERVED5 = 0x800,
            CLSCTX_NO_CUSTOM_MARSHAL = 0x1000,
            CLSCTX_ENABLE_CODE_DOWNLOAD = 0x2000,
            CLSCTX_NO_FAILURE_LOG = 0x4000,
            CLSCTX_DISABLE_AAA = 0x8000,
            CLSCTX_ENABLE_AAA = 0x10000,
            CLSCTX_FROM_DEFAULT_CONTEXT = 0x20000,
            CLSCTX_ACTIVATE_32_BIT_SERVER = 0x40000,
            CLSCTX_ACTIVATE_64_BIT_SERVER = 0x80000,
            CLSCTX_INPROC = CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
            CLSCTX_SERVER = CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
            CLSCTX_ALL = CLSCTX_SERVER | CLSCTX_INPROC_HANDLER
        }
    }
}
